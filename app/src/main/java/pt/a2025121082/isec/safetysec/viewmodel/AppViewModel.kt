package pt.a2025121082.isec.safetysec.viewmodel

import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.setValue
import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.google.firebase.firestore.GeoPoint
import dagger.hilt.android.lifecycle.HiltViewModel
import kotlinx.coroutines.launch
import pt.a2025121082.isec.safetysec.data.model.Alert
import pt.a2025121082.isec.safetysec.data.model.MonitoringRule
import pt.a2025121082.isec.safetysec.data.model.RuleParams
import pt.a2025121082.isec.safetysec.data.model.RuleType
import pt.a2025121082.isec.safetysec.data.model.TimeWindow
import pt.a2025121082.isec.safetysec.data.model.User
import pt.a2025121082.isec.safetysec.data.repository.AlertRepository
import pt.a2025121082.isec.safetysec.data.repository.AuthRepository
import pt.a2025121082.isec.safetysec.data.repository.MonitorRulesBundle
import pt.a2025121082.isec.safetysec.data.repository.MonitoringRepository
import javax.inject.Inject

/**
 * Global UI state for the main app flows (Protected + Monitor).
 *
 * Contains:
 * - loading/errors
 * - current user profile
 * - OTP association data
 * - Protected-specific data (rule bundles, time windows, alert history)
 * - state for the 10-second alert cancel window
 */
data class AppUiState(
    /** True when a background operation is running. */
    val isLoading: Boolean = false,

    /** Optional error message to display in the UI. */
    val error: String? = null,

    /** Current user's profile loaded from Firestore. */
    val me: User? = null,

    /** Latest OTP code generated by Protected (shown to be shared with Monitor). */
    val myOtp: String? = null,

    // -------------------------
    // Protected data
    // -------------------------

    /** Rule requests and authorizations grouped per Monitor. */
    val monitorRuleBundles: List<MonitorRulesBundle> = emptyList(),

    /** Configured time windows when rules may be active. */
    val timeWindows: List<TimeWindow> = emptyList(),

    /** Alerts list for Protected (placeholder for history storage). */
    val myAlerts: List<Alert> = emptyList(),

    // -------------------------
    // Alert cancel window state
    // -------------------------

    /** True when the 10-second cancel dialog should be visible. */
    val isCancelWindowOpen: Boolean = false,

    /** Seconds left in the cancel window countdown. */
    val cancelSecondsLeft: Int = 0,

    /**
     * Latest cancel code typed by the user in the dialog.
     * This is polled by AlertRepository via cancelCodeProvider.
     */
    val typedCancelCode: String? = null
)

/**
 * App-level ViewModel that coordinates:
 * - profile loading
 * - OTP association flows (Protected <-> Monitor)
 * - requesting rules (Monitor) and saving authorizations (Protected)
 * - time window management (Protected)
 * - panic alert triggering and cancellation flow
 */
@HiltViewModel
class AppViewModel @Inject constructor(
    private val authRepo: AuthRepository,
    private val monitoringRepo: MonitoringRepository,
    private val alertRepo: AlertRepository
) : ViewModel() {

    /** UI state observed by the app's Compose screens. */
    var state by mutableStateOf(AppUiState())
        private set

    /**
     * Resets the ViewModel UI state to defaults.
     * Useful on logout or when switching accounts.
     */
    fun clear() {
        state = AppUiState()
    }

    /**
     * Loads the current user's profile from Firestore.
     * If the user has the Protected role, also loads Protected-specific data.
     */
    fun loadMyProfile() = viewModelScope.launch {
        state = state.copy(isLoading = true, error = null)
        try {
            val me = authRepo.getUserProfile()
            state = state.copy(me = me, isLoading = false)

            // If I am Protected -> load data needed for Protected screens
            if (me.roles.contains("Protected")) {
                refreshProtectedData(me.uid)
            }
        } catch (t: Throwable) {
            state = state.copy(isLoading = false, error = t.message)
        }
    }

    /**
     * Refreshes data displayed in Protected screens:
     * - rule bundles requested by monitors + authorized types
     * - configured time windows
     */
    private fun refreshProtectedData(protectedUid: String) = viewModelScope.launch {
        try {
            val bundles = monitoringRepo.getRulesForProtected(protectedUid)
            val windows = monitoringRepo.listTimeWindows(protectedUid)
            state = state.copy(monitorRuleBundles = bundles, timeWindows = windows)
        } catch (t: Throwable) {
            // Soft error (Protected flow can still work partially)
            state = state.copy(error = t.message)
        }
    }

    // -------------------------
    // OTP association
    // -------------------------

    /**
     * Protected generates a one-time association code (OTP) to share with a Monitor.
     */
    fun generateOtp() = viewModelScope.launch {
        state = state.copy(isLoading = true, error = null)
        try {
            val code = authRepo.generateAssociationCode()
            state = state.copy(isLoading = false, myOtp = code)
        } catch (t: Throwable) {
            state = state.copy(isLoading = false, error = t.message)
        }
    }

    /**
     * Monitor links with a Protected user by entering the OTP.
     */
    fun linkWithOtp(code: String) = viewModelScope.launch {
        state = state.copy(isLoading = true, error = null)
        try {
            authRepo.linkWithAssociationCode(code)
            state = state.copy(isLoading = false)
            loadMyProfile()
        } catch (t: Throwable) {
            state = state.copy(isLoading = false, error = t.message)
        }
    }

    // -------------------------
    // Rules (Monitor requests / Protected authorizations)
    // -------------------------

    /**
     * Monitor requests a set of enabled rule types for a given Protected user.
     *
     * @param protectedUid Protected user's uid.
     * @param enabledTypes Selected rule types to request.
     * @param params Optional parameters shared by the requested rules.
     */
    fun requestRulesForProtected(
        protectedUid: String,
        enabledTypes: List<RuleType>,
        params: RuleParams
    ) = viewModelScope.launch {
        val me = state.me ?: return@launch
        state = state.copy(isLoading = true, error = null)
        try {
            val rules = enabledTypes.map { type ->
                MonitoringRule(type = type, params = params, enabled = true)
            }
            monitoringRepo.requestRules(
                protectedUid = protectedUid,
                monitorUid = me.uid,
                rules = rules
            )
            state = state.copy(isLoading = false)
        } catch (t: Throwable) {
            state = state.copy(isLoading = false, error = t.message)
        }
    }

    /**
     * Protected saves authorizations (allowed rule types) for a specific Monitor.
     */
    fun saveAuthorizations(monitorUid: String, authorized: List<RuleType>) = viewModelScope.launch {
        val me = state.me ?: return@launch // Protected user
        state = state.copy(isLoading = true, error = null)
        try {
            monitoringRepo.saveAuthorizations(me.uid, monitorUid, authorized)
            state = state.copy(isLoading = false)
            refreshProtectedData(me.uid)
        } catch (t: Throwable) {
            state = state.copy(isLoading = false, error = t.message)
        }
    }

    // -------------------------
    // Time windows
    // -------------------------

    /**
     * Adds a new time window for the current Protected user.
     * Performs basic validation using TimeWindow.isValid().
     */
    fun addTimeWindow(days: List<Int>, startHour: Int, endHour: Int) = viewModelScope.launch {
        val me = state.me ?: return@launch
        val window = TimeWindow(daysOfWeek = days, startHour = startHour, endHour = endHour)

        if (!window.isValid()) {
            state = state.copy(error = "Invalid time window")
            return@launch
        }

        state = state.copy(isLoading = true, error = null)
        try {
            monitoringRepo.addTimeWindow(me.uid, window)
            state = state.copy(isLoading = false)
            refreshProtectedData(me.uid)
        } catch (t: Throwable) {
            state = state.copy(isLoading = false, error = t.message)
        }
    }

    // -------------------------
    // Cancel PIN update
    // -------------------------

    /**
     * Updates the Protected user's alert cancellation PIN.
     */
    fun updateCancelPin(pin: String) = viewModelScope.launch {
        state = state.copy(isLoading = true, error = null)
        try {
            authRepo.updateAlertCancelCode(pin)
            state = state.copy(isLoading = false)
            loadMyProfile()
        } catch (t: Throwable) {
            state = state.copy(isLoading = false, error = t.message)
        }
    }

    // -------------------------
    // Panic alert + 10s cancel window
    // -------------------------

    /**
     * Triggers a PANIC alert and opens a 10-second cancel window.
     *
     * The AlertRepository polls [typedCancelCode] via cancelCodeProvider
     * to determine whether the user entered the correct PIN in time.
     */
    fun triggerPanic() = viewModelScope.launch {
        val me = state.me ?: return@launch
        if (!me.roles.contains("Protected")) {
            state = state.copy(error = "Only Protected can trigger panic.")
            return@launch
        }

        // Open cancel dialog for 10 seconds (UI reads cancelSecondsLeft).
        state = state.copy(isCancelWindowOpen = true, cancelSecondsLeft = 10)

        // Trigger alert (optional GPS/video are placeholders for now).
        val sent = alertRepo.triggerAlert(
            ruleType = RuleType.PANIC,
            user = me,
            cancelCodeProvider = { state.typedCancelCode },
            locationProvider = { GeoPoint(0.0, 0.0) }, // TODO: real GPS
            videoUriProvider = { null } // TODO: record 30s and provide Uri
        )

        // Close dialog and clear typed code.
        state = state.copy(isCancelWindowOpen = false, cancelSecondsLeft = 0, typedCancelCode = null)

        // If cancelled -> sent == false, otherwise true.
        if (!sent) {
            state = state.copy(error = "Alert cancelled.")
        }
    }

    /**
     * Updates the currently typed cancellation code.
     * This value is polled by AlertRepository during the 10-second window.
     */
    fun tryCancelAlert(typed: String) {
        state = state.copy(typedCancelCode = typed)
    }
}
